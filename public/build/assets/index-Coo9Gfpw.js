import{r as c,j as p,t as C}from"./app-COfnBwoK.js";function _(e,o,{checkForDefaultPrevented:t=!0}={}){return function(r){if(e?.(r),t===!1||!r.defaultPrevented)return o?.(r)}}function y(e,o){const t=c.createContext(o),i=u=>{const{children:s,...n}=u,a=c.useMemo(()=>n,Object.values(n));return p.jsx(t.Provider,{value:a,children:s})};i.displayName=e+"Provider";function r(u){const s=c.useContext(t);if(s)return s;if(o!==void 0)return o;throw new Error(`\`${u}\` must be used within \`${e}\``)}return[i,r]}function I(e,o=[]){let t=[];function i(u,s){const n=c.createContext(s),a=t.length;t=[...t,s];const d=l=>{const{scope:x,children:m,...v}=l,h=x?.[e]?.[a]||n,E=c.useMemo(()=>v,Object.values(v));return p.jsx(h.Provider,{value:E,children:m})};d.displayName=u+"Provider";function f(l,x){const m=x?.[e]?.[a]||n,v=c.useContext(m);if(v)return v;if(s!==void 0)return s;throw new Error(`\`${l}\` must be used within \`${u}\``)}return[d,f]}const r=()=>{const u=t.map(s=>c.createContext(s));return function(n){const a=n?.[e]||u;return c.useMemo(()=>({[`__scope${e}`]:{...n,[e]:a}}),[n,a])}};return r.scopeName=e,[i,P(r,...o)]}function P(...e){const o=e[0];if(e.length===1)return o;const t=()=>{const i=e.map(r=>({useScope:r(),scopeName:r.scopeName}));return function(u){const s=i.reduce((n,{useScope:a,scopeName:d})=>{const l=a(u)[`__scope${d}`];return{...n,...l}},{});return c.useMemo(()=>({[`__scope${o.scopeName}`]:s}),[s])}};return t.scopeName=o.scopeName,t}var S=globalThis?.document?c.useLayoutEffect:()=>{},$=C[" useId ".trim().toString()]||(()=>{}),b=0;function M(e){const[o,t]=c.useState($());return S(()=>{t(i=>i??String(b++))},[e]),e||(o?`radix-${o}`:"")}var w=C[" useInsertionEffect ".trim().toString()]||S;function k({prop:e,defaultProp:o,onChange:t=()=>{},caller:i}){const[r,u,s]=g({defaultProp:o,onChange:t}),n=e!==void 0,a=n?e:r;{const f=c.useRef(e!==void 0);c.useEffect(()=>{const l=f.current;l!==n&&console.warn(`${i} is changing from ${l?"controlled":"uncontrolled"} to ${n?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),f.current=n},[n,i])}const d=c.useCallback(f=>{if(n){const l=R(f)?f(e):f;l!==e&&s.current?.(l)}else u(f)},[n,e,u,s]);return[a,d]}function g({defaultProp:e,onChange:o}){const[t,i]=c.useState(e),r=c.useRef(t),u=c.useRef(o);return w(()=>{u.current=o},[o]),c.useEffect(()=>{r.current!==t&&(u.current?.(t),r.current=t)},[t,r]),[t,i,u]}function R(e){return typeof e=="function"}export{M as a,_ as b,I as c,S as d,y as e,k as u};
